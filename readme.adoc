
= MapStruct

== Overview
MapStruct is an annotation based java library with the goal of simplifying mapping logic.
The need for a model to model mapping is a common one, especially in integration code.
This need can spawn a myriad of methods of the following form:
------
ModelAObject modelBObjectToModelAObject(ModelBObject objectB);
------
Or perhaps:
------
void mapModelAToModelB(ModelAObject objectA, ModelBObject objectB);
------
When facing a huge model the logic of implementing a method like this can become inelegant.
Whether the size is overstretched due to the underlying complexity of the business process or to a programmer not adhering to the single responsibility principle often makes little difference in these situations.

It most often ends up being a sequence of null or empty checks with a setter call in the conditional body.
MapStruct aims to mitigate these issues by providing a generator of these kinds of mappers.

Here I will show a few basic examples how to setup and configurate generation.
The annotation and convention over configuration approach end up with less boiler plate code.

== Setup
The entire example code can be found in -----.
It is a simple maven project.
For a gradle or ant setup see MapStruct documentation.
For it to work mapstruct-jdk8 dependency is needed as well as maven-compiler-plugin configuration.
Example of the plugin configuration.
------
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.7.0</version>
    <configuration>
        <source>1.8</source>
        <target>1.8</target>
        <annotationProcessorPaths>
            <path>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>${lombok.version}</version>
            </path>
            <path>
                <groupId>org.mapstruct</groupId>
                <artifactId>mapstruct-processor</artifactId>
                <version>${org.mapstruct.version}</version>
            </path>
        </annotationProcessorPaths>
        <compilerArgs>
            <compilerArg>
                -Amapstruct.defaultComponentModel=spring
            </compilerArg>
        </compilerArgs>
    </configuration>
</plugin>
------
I added lombok dependency since I use lombok in my example.

The mapstruct-processor will generate an implementation class in maven compile lifecycle.

== Model Used for Presentation
Using a simple Person/PersonDTO model we can show an example of MapStruct usage.
------
import lombok.Data;
import java.time.LocalDate;

@Data
public class Person {
    private String fullName;
    private String address;
    private LocalDate dateOfBirth;
    private Car car;
}
------
------
import lombok.Data;

@Data
public class PersonDTO {
    private String firstName;
    private String lastName;
    private String residence;
    private String yearOfBirth;
    private CarDTO carDTO;
}
------
== Creating the mapper
To create a mapper we need to annotate an interface with org.mapstruct.Mapper.
Convention set in MapStruct documentation is to create a public static instance of the mapper in the interface using the Mappers factory.
------
@Mapper
public interface PersonMapper {

    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);

    @Mappings({
            ... Mapping annotations here
    })
    PersonDTO personToPersonDTO(Person person);

}
------
This way the mapper can be used as a static instance.
-----
PersonMapper.INSTANCE.personToPersonDTO(personObject)
-----
A different way of doing this would be autowiring Mappers as a bean.
The mapper annotation has a componentModel property whoose default value is spring.
When you generate a mapper it is automatically created as a bean.
------
@Autowired
private PersonMapper personMapper;
------
A third way of using the mapper is setting the component model to cdi which makes the mapper an application-scoped CDI bean.
Then it can be injected into a class using the @Inject annotation.
------
@Mapper(componentModel = "cdi")
...
@Inject
private PersonMapper personMapper;
------

=== Simple Case
In the most simple case when the field is mapped one-to-one the implementation is fairly simple.
------
@Mapping(source = "address", target = "residence", defaultValue = "unknown")
------
The address and residence are the same field with different names.
In the generated implementation this code will appear:
------
if (person.getAddress() != null) {
  personDTO.setResidence(person.getAddress());
}
else {
  personDTO.setResidence("unknown");
}
------
Unfortunately, this simple case is often not enough.
When implementing a model to model mapping the differences are often more than simply renamed fields.

=== Type conversion
When mapped fields are of different types it may not be possible to map them in a simple manner.
For most implicit type conversion MapStruct will handle conversion.
It can convert int to long, boolean to String.
In case of converting an int, BigDecimal or a number type to String we can use numberFormat parameter of the Mapping annotation to define the format.
The format String has to be able to be read by java.text.DecimalFormat.

==== Date to String
In case of Date to String transformation the dateFormat parameter can be used to specify the format String.
------
@Mapping(source = "dateOfBirth", target = "yearOfBirth", dateFormat = "yyyy")
------
Using this code generated will be:
------
if (person.getDateOfBirth() != null) {
  personDTO.setYearOfBirth(DateTimeFormatter.ofPattern("yyyy").format(person.getDateOfBirth()));
}
------
MapStruct supports org.yoda.time.* as well as java.sql.* or java.time.*

=== Expression
If the mapping logic can be expressed in a single line, expression can be a viable choice.
This is an example of mapping one field fullName to two fields firstName and lastName using expression.
------
@Mapping(target = "firstName", expression = "java(person.getFullName().split(\" \")[0])")
@Mapping(target = "lastName", expression = "java(person.getFullName().split(\" \")[1])")
------
The mapping generated result will be:
------
personDTO.setFirstName(person.getFullName().split(" ")[0]);
personDTO.setLastName(person.getFullName().split(" ")[1]);
------
There are obvious problems.
What if fullName is null or empty?
What if it's a single word?
This would require us to expand the expression to something like this:
------
(StringUtils.isNotEmpty(person.getFullName()) && person.getFullName().split(\" \").length > 1) ? person.getFullName().split(\" \")[0] : ""
------
Obviously, a single expression can grow too long and hard to maintain, so it should be used carefully.
MapStruct expression at this point supports only java expressions, but the plan was to expand this list.
This is why the expression must be wrapped in java(/expression/).

=== More Complex Mapping
If mapping logic can't be fulfilled with naming the source and target, with automatic type casting or with an expression, then we will have to expand the mapper.


=== Suggestion on use

== Conclusion

== Documentation
